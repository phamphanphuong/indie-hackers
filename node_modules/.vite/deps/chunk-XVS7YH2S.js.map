{
  "version": 3,
  "sources": ["../../devlop/lib/development.js", "../../@ungap/structured-clone/esm/types.js", "../../@ungap/structured-clone/esm/deserialize.js", "../../@ungap/structured-clone/esm/serialize.js", "../../@ungap/structured-clone/esm/index.js", "../../unist-util-is/lib/index.js", "../../unist-util-visit-parents/lib/color.js", "../../unist-util-visit-parents/lib/index.js", "../../unist-util-visit/lib/index.js", "../../unist-util-position/lib/index.js"],
  "sourcesContent": ["import {dequal} from 'dequal'\r\n\r\n/**\r\n * @type {Set<string>}\r\n */\r\nconst codesWarned = new Set()\r\n\r\nclass AssertionError extends Error {\r\n  name = /** @type {const} */ ('Assertion')\r\n  code = /** @type {const} */ ('ERR_ASSERTION')\r\n\r\n  /**\r\n   * Create an assertion error.\r\n   *\r\n   * @param {string} message\r\n   *   Message explaining error.\r\n   * @param {unknown} actual\r\n   *   Value.\r\n   * @param {unknown} expected\r\n   *   Baseline.\r\n   * @param {string} operator\r\n   *   Name of equality operation.\r\n   * @param {boolean} generated\r\n   *   Whether `message` is a custom message or not\r\n   * @returns\r\n   *   Instance.\r\n   */\r\n  // eslint-disable-next-line max-params\r\n  constructor(message, actual, expected, operator, generated) {\r\n    super(message)\r\n\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, this.constructor)\r\n    }\r\n\r\n    /**\r\n     * @type {unknown}\r\n     */\r\n    this.actual = actual\r\n\r\n    /**\r\n     * @type {unknown}\r\n     */\r\n    this.expected = expected\r\n\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    this.generated = generated\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    this.operator = operator\r\n  }\r\n}\r\n\r\nclass DeprecationError extends Error {\r\n  name = /** @type {const} */ ('DeprecationWarning')\r\n\r\n  /**\r\n   * Create a deprecation message.\r\n   *\r\n   * @param {string} message\r\n   *   Message explaining deprecation.\r\n   * @param {string | undefined} code\r\n   *   Deprecation identifier; deprecation messages will be generated only once per code.\r\n   * @returns\r\n   *   Instance.\r\n   */\r\n  constructor(message, code) {\r\n    super(message)\r\n\r\n    /**\r\n     * @type {string | undefined}\r\n     */\r\n    this.code = code\r\n  }\r\n}\r\n\r\n/**\r\n * Wrap a function or class to show a deprecation message when first called.\r\n *\r\n * > ðŸ‘‰ **Important**: only shows a message when the `development` condition is\r\n * > used, does nothing in production.\r\n *\r\n * When the resulting wrapped `fn` is called, emits a warning once to\r\n * `console.error` (`stderr`).\r\n * If a code is given, one warning message will be emitted in total per code.\r\n *\r\n * @template {Function} T\r\n *   Function or class kind.\r\n * @param {T} fn\r\n *   Function or class.\r\n * @param {string} message\r\n *   Message explaining deprecation.\r\n * @param {string | null | undefined} [code]\r\n *   Deprecation identifier (optional); deprecation messages will be generated\r\n *   only once per code.\r\n * @returns {T}\r\n *   Wrapped `fn`.\r\n */\r\nexport function deprecate(fn, message, code) {\r\n  let warned = false\r\n\r\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\r\n  Object.setPrototypeOf(deprecated, fn)\r\n\r\n  // @ts-expect-error: itâ€™s perfect, typescriptâ€¦\r\n  return deprecated\r\n\r\n  /**\r\n   * @this {unknown}\r\n   * @param  {...Array<unknown>} args\r\n   * @returns {unknown}\r\n   */\r\n  function deprecated(...args) {\r\n    if (!warned) {\r\n      warned = true\r\n\r\n      if (typeof code === 'string' && codesWarned.has(code)) {\r\n        // Empty.\r\n      } else {\r\n        console.error(new DeprecationError(message, code || undefined))\r\n\r\n        if (typeof code === 'string') codesWarned.add(code)\r\n      }\r\n    }\r\n\r\n    return new.target\r\n      ? Reflect.construct(fn, args, new.target)\r\n      : Reflect.apply(fn, this, args)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert deep strict equivalence.\r\n *\r\n * > ðŸ‘‰ **Important**: only asserts when the `development` condition is used,\r\n * > does nothing in production.\r\n *\r\n * @template {unknown} T\r\n *   Expected kind.\r\n * @param {unknown} actual\r\n *   Value.\r\n * @param {T} expected\r\n *   Baseline.\r\n * @param {Error | string | null | undefined} [message]\r\n *   Message for assertion error (default: `'Expected values to be deeply equal'`).\r\n * @returns {asserts actual is T}\r\n *   Nothing; throws when `actual` is not deep strict equal to `expected`.\r\n * @throws {AssertionError}\r\n *   Throws when `actual` is not deep strict equal to `expected`.\r\n */\r\nexport function equal(actual, expected, message) {\r\n  assert(\r\n    dequal(actual, expected),\r\n    actual,\r\n    expected,\r\n    'equal',\r\n    'Expected values to be deeply equal',\r\n    message\r\n  )\r\n}\r\n\r\n/**\r\n * Assert if `value` is truthy.\r\n *\r\n * > ðŸ‘‰ **Important**: only asserts when the `development` condition is used,\r\n * > does nothing in production.\r\n *\r\n * @param {unknown} value\r\n *   Value to assert.\r\n * @param {Error | string | null | undefined} [message]\r\n *   Message for assertion error (default: `'Expected value to be truthy'`).\r\n * @returns {asserts value}\r\n *   Nothing; throws when `value` is falsey.\r\n * @throws {AssertionError}\r\n *   Throws when `value` is falsey.\r\n */\r\nexport function ok(value, message) {\r\n  assert(\r\n    Boolean(value),\r\n    false,\r\n    true,\r\n    'ok',\r\n    'Expected value to be truthy',\r\n    message\r\n  )\r\n}\r\n\r\n/**\r\n * Assert that a code path never happens.\r\n *\r\n * > ðŸ‘‰ **Important**: only asserts when the `development` condition is used,\r\n * > does nothing in production.\r\n *\r\n * @param {Error | string | null | undefined} [message]\r\n *   Message for assertion error (default: `'Unreachable'`).\r\n * @returns {never}\r\n *   Nothing; always throws.\r\n * @throws {AssertionError}\r\n *   Throws when `value` is falsey.\r\n */\r\nexport function unreachable(message) {\r\n  assert(false, false, true, 'ok', 'Unreachable', message)\r\n}\r\n\r\n/**\r\n * @param {boolean} bool\r\n *   Whether to skip this operation.\r\n * @param {unknown} actual\r\n *   Actual value.\r\n * @param {unknown} expected\r\n *   Expected value.\r\n * @param {string} operator\r\n *   Operator.\r\n * @param {string} defaultMessage\r\n *   Default message for operation.\r\n * @param {Error | string | null | undefined} userMessage\r\n *   User-provided message.\r\n * @returns {asserts bool}\r\n *   Nothing; throws when falsey.\r\n */\r\n// eslint-disable-next-line max-params\r\nfunction assert(bool, actual, expected, operator, defaultMessage, userMessage) {\r\n  if (!bool) {\r\n    throw userMessage instanceof Error\r\n      ? userMessage\r\n      : new AssertionError(\r\n          userMessage || defaultMessage,\r\n          actual,\r\n          expected,\r\n          operator,\r\n          !userMessage\r\n        )\r\n  }\r\n}\r\n", "export const VOID       = -1;\r\nexport const PRIMITIVE  = 0;\r\nexport const ARRAY      = 1;\r\nexport const OBJECT     = 2;\r\nexport const DATE       = 3;\r\nexport const REGEXP     = 4;\r\nexport const MAP        = 5;\r\nexport const SET        = 6;\r\nexport const ERROR      = 7;\r\nexport const BIGINT     = 8;\r\n// export const SYMBOL = 9;\r\n", "import {\r\n  VOID, PRIMITIVE,\r\n  ARRAY, OBJECT,\r\n  DATE, REGEXP, MAP, SET,\r\n  ERROR, BIGINT\r\n} from './types.js';\r\n\r\nconst env = typeof self === 'object' ? self : globalThis;\r\n\r\nconst deserializer = ($, _) => {\r\n  const as = (out, index) => {\r\n    $.set(index, out);\r\n    return out;\r\n  };\r\n\r\n  const unpair = index => {\r\n    if ($.has(index))\r\n      return $.get(index);\r\n\r\n    const [type, value] = _[index];\r\n    switch (type) {\r\n      case PRIMITIVE:\r\n      case VOID:\r\n        return as(value, index);\r\n      case ARRAY: {\r\n        const arr = as([], index);\r\n        for (const index of value)\r\n          arr.push(unpair(index));\r\n        return arr;\r\n      }\r\n      case OBJECT: {\r\n        const object = as({}, index);\r\n        for (const [key, index] of value)\r\n          object[unpair(key)] = unpair(index);\r\n        return object;\r\n      }\r\n      case DATE:\r\n        return as(new Date(value), index);\r\n      case REGEXP: {\r\n        const {source, flags} = value;\r\n        return as(new RegExp(source, flags), index);\r\n      }\r\n      case MAP: {\r\n        const map = as(new Map, index);\r\n        for (const [key, index] of value)\r\n          map.set(unpair(key), unpair(index));\r\n        return map;\r\n      }\r\n      case SET: {\r\n        const set = as(new Set, index);\r\n        for (const index of value)\r\n          set.add(unpair(index));\r\n        return set;\r\n      }\r\n      case ERROR: {\r\n        const {name, message} = value;\r\n        return as(new env[name](message), index);\r\n      }\r\n      case BIGINT:\r\n        return as(BigInt(value), index);\r\n      case 'BigInt':\r\n        return as(Object(BigInt(value)), index);\r\n      case 'ArrayBuffer':\r\n        return as(new Uint8Array(value).buffer, value);\r\n      case 'DataView': {\r\n        const { buffer } = new Uint8Array(value);\r\n        return as(new DataView(buffer), value);\r\n      }\r\n    }\r\n    return as(new env[type](value), index);\r\n  };\r\n\r\n  return unpair;\r\n};\r\n\r\n/**\r\n * @typedef {Array<string,any>} Record a type representation\r\n */\r\n\r\n/**\r\n * Returns a deserialized value from a serialized array of Records.\r\n * @param {Record[]} serialized a previously serialized value.\r\n * @returns {any}\r\n */\r\nexport const deserialize = serialized => deserializer(new Map, serialized)(0);\r\n", "import {\r\n  VOID, PRIMITIVE,\r\n  ARRAY, OBJECT,\r\n  DATE, REGEXP, MAP, SET,\r\n  ERROR, BIGINT\r\n} from './types.js';\r\n\r\nconst EMPTY = '';\r\n\r\nconst {toString} = {};\r\nconst {keys} = Object;\r\n\r\nconst typeOf = value => {\r\n  const type = typeof value;\r\n  if (type !== 'object' || !value)\r\n    return [PRIMITIVE, type];\r\n\r\n  const asString = toString.call(value).slice(8, -1);\r\n  switch (asString) {\r\n    case 'Array':\r\n      return [ARRAY, EMPTY];\r\n    case 'Object':\r\n      return [OBJECT, EMPTY];\r\n    case 'Date':\r\n      return [DATE, EMPTY];\r\n    case 'RegExp':\r\n      return [REGEXP, EMPTY];\r\n    case 'Map':\r\n      return [MAP, EMPTY];\r\n    case 'Set':\r\n      return [SET, EMPTY];\r\n    case 'DataView':\r\n      return [ARRAY, asString];\r\n  }\r\n\r\n  if (asString.includes('Array'))\r\n    return [ARRAY, asString];\r\n\r\n  if (asString.includes('Error'))\r\n    return [ERROR, asString];\r\n\r\n  return [OBJECT, asString];\r\n};\r\n\r\nconst shouldSkip = ([TYPE, type]) => (\r\n  TYPE === PRIMITIVE &&\r\n  (type === 'function' || type === 'symbol')\r\n);\r\n\r\nconst serializer = (strict, json, $, _) => {\r\n\r\n  const as = (out, value) => {\r\n    const index = _.push(out) - 1;\r\n    $.set(value, index);\r\n    return index;\r\n  };\r\n\r\n  const pair = value => {\r\n    if ($.has(value))\r\n      return $.get(value);\r\n\r\n    let [TYPE, type] = typeOf(value);\r\n    switch (TYPE) {\r\n      case PRIMITIVE: {\r\n        let entry = value;\r\n        switch (type) {\r\n          case 'bigint':\r\n            TYPE = BIGINT;\r\n            entry = value.toString();\r\n            break;\r\n          case 'function':\r\n          case 'symbol':\r\n            if (strict)\r\n              throw new TypeError('unable to serialize ' + type);\r\n            entry = null;\r\n            break;\r\n          case 'undefined':\r\n            return as([VOID], value);\r\n        }\r\n        return as([TYPE, entry], value);\r\n      }\r\n      case ARRAY: {\r\n        if (type) {\r\n          let spread = value;\r\n          if (type === 'DataView') {\r\n            spread = new Uint8Array(value.buffer);\r\n          }\r\n          else if (type === 'ArrayBuffer') {\r\n            spread = new Uint8Array(value);\r\n          }\r\n          return as([type, [...spread]], value);\r\n        }\r\n\r\n        const arr = [];\r\n        const index = as([TYPE, arr], value);\r\n        for (const entry of value)\r\n          arr.push(pair(entry));\r\n        return index;\r\n      }\r\n      case OBJECT: {\r\n        if (type) {\r\n          switch (type) {\r\n            case 'BigInt':\r\n              return as([type, value.toString()], value);\r\n            case 'Boolean':\r\n            case 'Number':\r\n            case 'String':\r\n              return as([type, value.valueOf()], value);\r\n          }\r\n        }\r\n\r\n        if (json && ('toJSON' in value))\r\n          return pair(value.toJSON());\r\n\r\n        const entries = [];\r\n        const index = as([TYPE, entries], value);\r\n        for (const key of keys(value)) {\r\n          if (strict || !shouldSkip(typeOf(value[key])))\r\n            entries.push([pair(key), pair(value[key])]);\r\n        }\r\n        return index;\r\n      }\r\n      case DATE:\r\n        return as([TYPE, value.toISOString()], value);\r\n      case REGEXP: {\r\n        const {source, flags} = value;\r\n        return as([TYPE, {source, flags}], value);\r\n      }\r\n      case MAP: {\r\n        const entries = [];\r\n        const index = as([TYPE, entries], value);\r\n        for (const [key, entry] of value) {\r\n          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))\r\n            entries.push([pair(key), pair(entry)]);\r\n        }\r\n        return index;\r\n      }\r\n      case SET: {\r\n        const entries = [];\r\n        const index = as([TYPE, entries], value);\r\n        for (const entry of value) {\r\n          if (strict || !shouldSkip(typeOf(entry)))\r\n            entries.push(pair(entry));\r\n        }\r\n        return index;\r\n      }\r\n    }\r\n\r\n    const {message} = value;\r\n    return as([TYPE, {name: type, message}], value);\r\n  };\r\n\r\n  return pair;\r\n};\r\n\r\n/**\r\n * @typedef {Array<string,any>} Record a type representation\r\n */\r\n\r\n/**\r\n * Returns an array of serialized Records.\r\n * @param {any} value a serializable value.\r\n * @param {{json?: boolean, lossy?: boolean}?} options an object with a `lossy` or `json` property that,\r\n *  if `true`, will not throw errors on incompatible types, and behave more\r\n *  like JSON stringify would behave. Symbol and Function will be discarded.\r\n * @returns {Record[]}\r\n */\r\n export const serialize = (value, {json, lossy} = {}) => {\r\n  const _ = [];\r\n  return serializer(!(json || lossy), !!json, new Map, _)(value), _;\r\n};\r\n", "import {deserialize} from './deserialize.js';\r\nimport {serialize} from './serialize.js';\r\n\r\n/**\r\n * @typedef {Array<string,any>} Record a type representation\r\n */\r\n\r\n/**\r\n * Returns an array of serialized Records.\r\n * @param {any} any a serializable value.\r\n * @param {{transfer?: any[], json?: boolean, lossy?: boolean}?} options an object with\r\n * a transfer option (ignored when polyfilled) and/or non standard fields that\r\n * fallback to the polyfill if present.\r\n * @returns {Record[]}\r\n */\r\nexport default typeof structuredClone === \"function\" ?\r\n  /* c8 ignore start */\r\n  (any, options) => (\r\n    options && ('json' in options || 'lossy' in options) ?\r\n      deserialize(serialize(any, options)) : structuredClone(any)\r\n  ) :\r\n  (any, options) => deserialize(serialize(any, options));\r\n  /* c8 ignore stop */\r\n\r\nexport {deserialize, serialize};\r\n", "/**\r\n * @import {Node, Parent} from 'unist'\r\n */\r\n\r\n/**\r\n * @template Fn\r\n * @template Fallback\r\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\r\n */\r\n\r\n/**\r\n * @callback Check\r\n *   Check that an arbitrary value is a node.\r\n * @param {unknown} this\r\n *   The given context.\r\n * @param {unknown} [node]\r\n *   Anything (typically a node).\r\n * @param {number | null | undefined} [index]\r\n *   The nodeâ€™s position in its parent.\r\n * @param {Parent | null | undefined} [parent]\r\n *   The nodeâ€™s parent.\r\n * @returns {boolean}\r\n *   Whether this is a node and passes a test.\r\n *\r\n * @typedef {Record<string, unknown> | Node} Props\r\n *   Object to check for equivalence.\r\n *\r\n *   Note: `Node` is included as it is common but is not indexable.\r\n *\r\n * @typedef {Array<Props | TestFunction | string> | ReadonlyArray<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\r\n *   Check for an arbitrary node.\r\n *\r\n * @callback TestFunction\r\n *   Check if a node passes a test.\r\n * @param {unknown} this\r\n *   The given context.\r\n * @param {Node} node\r\n *   A node.\r\n * @param {number | undefined} [index]\r\n *   The nodeâ€™s position in its parent.\r\n * @param {Parent | undefined} [parent]\r\n *   The nodeâ€™s parent.\r\n * @returns {boolean | undefined | void}\r\n *   Whether this node passes the test.\r\n *\r\n *   Note: `void` is included until TS sees no return as `undefined`.\r\n */\r\n\r\n/**\r\n * Check if `node` is a `Node` and whether it passes the given test.\r\n *\r\n * @param {unknown} node\r\n *   Thing to check, typically `Node`.\r\n * @param {Test} test\r\n *   A check for a specific node.\r\n * @param {number | null | undefined} index\r\n *   The nodeâ€™s position in its parent.\r\n * @param {Parent | null | undefined} parent\r\n *   The nodeâ€™s parent.\r\n * @param {unknown} context\r\n *   Context object (`this`) to pass to `test` functions.\r\n * @returns {boolean}\r\n *   Whether `node` is a node and passes a test.\r\n */\r\nexport const is =\r\n  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.\r\n  /**\r\n   * @type {(\r\n   *   (<Condition extends ReadonlyArray<string>>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition[number]}) &\r\n   *   (<Condition extends Array<string>>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition[number]}) &\r\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\r\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\r\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\r\n   *   ((node?: null | undefined) => false) &\r\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\r\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {unknown} [node]\r\n     * @param {Test} [test]\r\n     * @param {number | null | undefined} [index]\r\n     * @param {Parent | null | undefined} [parent]\r\n     * @param {unknown} [context]\r\n     * @returns {boolean}\r\n     */\r\n    // eslint-disable-next-line max-params\r\n    function (node, test, index, parent, context) {\r\n      const check = convert(test)\r\n\r\n      if (\r\n        index !== undefined &&\r\n        index !== null &&\r\n        (typeof index !== 'number' ||\r\n          index < 0 ||\r\n          index === Number.POSITIVE_INFINITY)\r\n      ) {\r\n        throw new Error('Expected positive finite index')\r\n      }\r\n\r\n      if (\r\n        parent !== undefined &&\r\n        parent !== null &&\r\n        (!is(parent) || !parent.children)\r\n      ) {\r\n        throw new Error('Expected parent node')\r\n      }\r\n\r\n      if (\r\n        (parent === undefined || parent === null) !==\r\n        (index === undefined || index === null)\r\n      ) {\r\n        throw new Error('Expected both parent and index')\r\n      }\r\n\r\n      return looksLikeANode(node)\r\n        ? check.call(context, node, index, parent)\r\n        : false\r\n    }\r\n  )\r\n\r\n/**\r\n * Generate an assertion from a test.\r\n *\r\n * Useful if youâ€™re going to test many nodes, for example when creating a\r\n * utility where something else passes a compatible test.\r\n *\r\n * The created function is a bit faster because it expects valid input only:\r\n * a `node`, `index`, and `parent`.\r\n *\r\n * @param {Test} test\r\n *   *   when nullish, checks if `node` is a `Node`.\r\n *   *   when `string`, works like passing `(node) => node.type === test`.\r\n *   *   when `function` checks if function passed the node is true.\r\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\r\n *   *   when `array`, checks if any one of the subtests pass.\r\n * @returns {Check}\r\n *   An assertion.\r\n */\r\nexport const convert =\r\n  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.\r\n  /**\r\n   * @type {(\r\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\r\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\r\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\r\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\r\n   *   ((test?: Test) => Check)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {Test} [test]\r\n     * @returns {Check}\r\n     */\r\n    function (test) {\r\n      if (test === null || test === undefined) {\r\n        return ok\r\n      }\r\n\r\n      if (typeof test === 'function') {\r\n        return castFactory(test)\r\n      }\r\n\r\n      if (typeof test === 'object') {\r\n        return Array.isArray(test)\r\n          ? anyFactory(test)\r\n          : // Cast because `ReadonlyArray` goes into the above but `isArray`\r\n            // narrows to `Array`.\r\n            propertiesFactory(/** @type {Props} */ (test))\r\n      }\r\n\r\n      if (typeof test === 'string') {\r\n        return typeFactory(test)\r\n      }\r\n\r\n      throw new Error('Expected function, string, or object as test')\r\n    }\r\n  )\r\n\r\n/**\r\n * @param {Array<Props | TestFunction | string>} tests\r\n * @returns {Check}\r\n */\r\nfunction anyFactory(tests) {\r\n  /** @type {Array<Check>} */\r\n  const checks = []\r\n  let index = -1\r\n\r\n  while (++index < tests.length) {\r\n    checks[index] = convert(tests[index])\r\n  }\r\n\r\n  return castFactory(any)\r\n\r\n  /**\r\n   * @this {unknown}\r\n   * @type {TestFunction}\r\n   */\r\n  function any(...parameters) {\r\n    let index = -1\r\n\r\n    while (++index < checks.length) {\r\n      if (checks[index].apply(this, parameters)) return true\r\n    }\r\n\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Turn an object into a test for a node with a certain fields.\r\n *\r\n * @param {Props} check\r\n * @returns {Check}\r\n */\r\nfunction propertiesFactory(check) {\r\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\r\n\r\n  return castFactory(all)\r\n\r\n  /**\r\n   * @param {Node} node\r\n   * @returns {boolean}\r\n   */\r\n  function all(node) {\r\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\r\n      /** @type {unknown} */ (node)\r\n    )\r\n\r\n    /** @type {string} */\r\n    let key\r\n\r\n    for (key in check) {\r\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\r\n    }\r\n\r\n    return true\r\n  }\r\n}\r\n\r\n/**\r\n * Turn a string into a test for a node with a certain type.\r\n *\r\n * @param {string} check\r\n * @returns {Check}\r\n */\r\nfunction typeFactory(check) {\r\n  return castFactory(type)\r\n\r\n  /**\r\n   * @param {Node} node\r\n   */\r\n  function type(node) {\r\n    return node && node.type === check\r\n  }\r\n}\r\n\r\n/**\r\n * Turn a custom test into a test for a node that passes that test.\r\n *\r\n * @param {TestFunction} testFunction\r\n * @returns {Check}\r\n */\r\nfunction castFactory(testFunction) {\r\n  return check\r\n\r\n  /**\r\n   * @this {unknown}\r\n   * @type {Check}\r\n   */\r\n  function check(value, index, parent) {\r\n    return Boolean(\r\n      looksLikeANode(value) &&\r\n        testFunction.call(\r\n          this,\r\n          value,\r\n          typeof index === 'number' ? index : undefined,\r\n          parent || undefined\r\n        )\r\n    )\r\n  }\r\n}\r\n\r\nfunction ok() {\r\n  return true\r\n}\r\n\r\n/**\r\n * @param {unknown} value\r\n * @returns {value is Node}\r\n */\r\nfunction looksLikeANode(value) {\r\n  return value !== null && typeof value === 'object' && 'type' in value\r\n}\r\n", "/**\r\n * @param {string} d\r\n * @returns {string}\r\n */\r\nexport function color(d) {\r\n  return d\r\n}\r\n", "/**\r\n * @import {Node as UnistNode, Parent as UnistParent} from 'unist'\r\n */\r\n\r\n/**\r\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\r\n *   Test from `unist-util-is`.\r\n *\r\n *   Note: we have remove and add `undefined`, because otherwise when generating\r\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\r\n *   which doesnâ€™t work when publishing on npm.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Fn extends (value: any) => value is infer Thing\r\n *   ? Thing\r\n *   : Fallback\r\n * )} Predicate\r\n *   Get the value of a type guard `Fn`.\r\n * @template Fn\r\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\r\n * @template Fallback\r\n *   Value to yield if `Fn` is not a type guard.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Check extends null | undefined // No test.\r\n *   ? Value\r\n *   : Value extends {type: Check} // String (type) test.\r\n *   ? Value\r\n *   : Value extends Check // Partial test.\r\n *   ? Value\r\n *   : Check extends Function // Function test.\r\n *   ? Predicate<Check, Value> extends Value\r\n *     ? Predicate<Check, Value>\r\n *     : never\r\n *   : never // Some other test?\r\n * )} MatchesOne\r\n *   Check whether a node matches a primitive check in the type system.\r\n * @template Value\r\n *   Value; typically unist `Node`.\r\n * @template Check\r\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Check extends ReadonlyArray<infer T>\r\n *   ? MatchesOne<Value, T>\r\n *   : Check extends Array<infer T>\r\n *   ? MatchesOne<Value, T>\r\n *   : MatchesOne<Value, Check>\r\n * )} Matches\r\n *   Check whether a node matches a check in the type system.\r\n * @template Value\r\n *   Value; typically unist `Node`.\r\n * @template Check\r\n *   Value; typically `unist-util-is`-compatible test.\r\n */\r\n\r\n/**\r\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\r\n *   Number; capped reasonably.\r\n */\r\n\r\n/**\r\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\r\n *   Increment a number in the type system.\r\n * @template {Uint} [I=0]\r\n *   Index.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Node extends UnistParent\r\n *   ? Node extends {children: Array<infer Children>}\r\n *     ? Child extends Children ? Node : never\r\n *     : never\r\n *   : never\r\n * )} InternalParent\r\n *   Collect nodes that can be parents of `Child`.\r\n * @template {UnistNode} Node\r\n *   All node types in a tree.\r\n * @template {UnistNode} Child\r\n *   Node to search for.\r\n */\r\n\r\n/**\r\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\r\n *   Collect nodes in `Tree` that can be parents of `Child`.\r\n * @template {UnistNode} Tree\r\n *   All node types in a tree.\r\n * @template {UnistNode} Child\r\n *   Node to search for.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Depth extends Max\r\n *   ? never\r\n *   :\r\n *     | InternalParent<Node, Child>\r\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\r\n * )} InternalAncestor\r\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\r\n * @template {UnistNode} Node\r\n *   All node types in a tree.\r\n * @template {UnistNode} Child\r\n *   Node to search for.\r\n * @template {Uint} [Max=10]\r\n *   Max; searches up to this depth.\r\n * @template {Uint} [Depth=0]\r\n *   Current depth.\r\n */\r\n\r\n/**\r\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\r\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\r\n * @template {UnistNode} Tree\r\n *   All node types in a tree.\r\n * @template {UnistNode} Child\r\n *   Node to search for.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Tree extends UnistParent\r\n *     ? Depth extends Max\r\n *       ? Tree\r\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\r\n *     : Tree\r\n * )} InclusiveDescendant\r\n *   Collect all (inclusive) descendants of `Tree`.\r\n *\r\n *   > ðŸ‘‰ **Note**: for performance reasons, this seems to be the fastest way to\r\n *   > recurse without actually running into an infinite loop, which the\r\n *   > previous version did.\r\n *   >\r\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\r\n *   > passed, but it doesnâ€™t improve performance.\r\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\r\n *   > Using up to `10` doesnâ€™t hurt or help either.\r\n * @template {UnistNode} Tree\r\n *   Tree type.\r\n * @template {Uint} [Max=10]\r\n *   Max; searches up to this depth.\r\n * @template {Uint} [Depth=0]\r\n *   Current depth.\r\n */\r\n\r\n/**\r\n * @typedef {'skip' | boolean} Action\r\n *   Union of the action types.\r\n *\r\n * @typedef {number} Index\r\n *   Move to the sibling at `index` next (after node itself is completely\r\n *   traversed).\r\n *\r\n *   Useful if mutating the tree, such as removing the node the visitor is\r\n *   currently on, or any of its previous siblings.\r\n *   Results less than 0 or greater than or equal to `children.length` stop\r\n *   traversing the parent.\r\n *\r\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\r\n *   List with one or two values, the first an action, the second an index.\r\n *\r\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\r\n *   Any value that can be returned from a visitor.\r\n */\r\n\r\n/**\r\n * @callback Visitor\r\n *   Handle a node (matching `test`, if given).\r\n *\r\n *   Visitors are free to transform `node`.\r\n *   They can also transform the parent of node (the last of `ancestors`).\r\n *\r\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\r\n *   descendants to be walked (which is a bug).\r\n *\r\n *   When adding or removing previous siblings of `node` (or next siblings, in\r\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\r\n *   sibling to traverse after `node` is traversed.\r\n *   Adding or removing next siblings of `node` (or previous siblings, in case\r\n *   of reverse) is handled as expected without needing to return a new `Index`.\r\n *\r\n *   Removing the children property of an ancestor still results in them being\r\n *   traversed.\r\n * @param {Visited} node\r\n *   Found node.\r\n * @param {Array<VisitedParents>} ancestors\r\n *   Ancestors of `node`.\r\n * @returns {VisitorResult}\r\n *   What to do next.\r\n *\r\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\r\n *   An `Action` is treated as a tuple of `[Action]`.\r\n *\r\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\r\n *   When the `Action` is `EXIT`, that action can be returned.\r\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\r\n * @template {UnistNode} [Visited=UnistNode]\r\n *   Visited node type.\r\n * @template {UnistParent} [VisitedParents=UnistParent]\r\n *   Ancestor type.\r\n */\r\n\r\n/**\r\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\r\n *   Build a typed `Visitor` function from a tree and a test.\r\n *\r\n *   It will infer which values are passed as `node` and which as `parents`.\r\n * @template {UnistNode} [Tree=UnistNode]\r\n *   Tree type.\r\n * @template {Test} [Check=Test]\r\n *   Test type.\r\n */\r\n\r\nimport {convert} from 'unist-util-is'\r\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\r\n\r\n/** @type {Readonly<ActionTuple>} */\r\nconst empty = []\r\n\r\n/**\r\n * Continue traversing as normal.\r\n */\r\nexport const CONTINUE = true\r\n\r\n/**\r\n * Stop traversing immediately.\r\n */\r\nexport const EXIT = false\r\n\r\n/**\r\n * Do not traverse this nodeâ€™s children.\r\n */\r\nexport const SKIP = 'skip'\r\n\r\n/**\r\n * Visit nodes, with ancestral information.\r\n *\r\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\r\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\r\n *\r\n * You can choose for which nodes `visitor` is called by passing a `test`.\r\n * For complex tests, you should test yourself in `visitor`, as it will be\r\n * faster and will have improved type information.\r\n *\r\n * Walking the tree is an intensive task.\r\n * Make use of the return values of the visitor when possible.\r\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\r\n * to check if a node matches, and then perform different operations.\r\n *\r\n * You can change the tree.\r\n * See `Visitor` for more info.\r\n *\r\n * @overload\r\n * @param {Tree} tree\r\n * @param {Check} check\r\n * @param {BuildVisitor<Tree, Check>} visitor\r\n * @param {boolean | null | undefined} [reverse]\r\n * @returns {undefined}\r\n *\r\n * @overload\r\n * @param {Tree} tree\r\n * @param {BuildVisitor<Tree>} visitor\r\n * @param {boolean | null | undefined} [reverse]\r\n * @returns {undefined}\r\n *\r\n * @param {UnistNode} tree\r\n *   Tree to traverse.\r\n * @param {Visitor | Test} test\r\n *   `unist-util-is`-compatible test\r\n * @param {Visitor | boolean | null | undefined} [visitor]\r\n *   Handle each node.\r\n * @param {boolean | null | undefined} [reverse]\r\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\r\n * @returns {undefined}\r\n *   Nothing.\r\n *\r\n * @template {UnistNode} Tree\r\n *   Node type.\r\n * @template {Test} Check\r\n *   `unist-util-is`-compatible test.\r\n */\r\nexport function visitParents(tree, test, visitor, reverse) {\r\n  /** @type {Test} */\r\n  let check\r\n\r\n  if (typeof test === 'function' && typeof visitor !== 'function') {\r\n    reverse = visitor\r\n    // @ts-expect-error no visitor given, so `visitor` is test.\r\n    visitor = test\r\n  } else {\r\n    // @ts-expect-error visitor given, so `test` isnâ€™t a visitor.\r\n    check = test\r\n  }\r\n\r\n  const is = convert(check)\r\n  const step = reverse ? -1 : 1\r\n\r\n  factory(tree, undefined, [])()\r\n\r\n  /**\r\n   * @param {UnistNode} node\r\n   * @param {number | undefined} index\r\n   * @param {Array<UnistParent>} parents\r\n   */\r\n  function factory(node, index, parents) {\r\n    const value = /** @type {Record<string, unknown>} */ (\r\n      node && typeof node === 'object' ? node : {}\r\n    )\r\n\r\n    if (typeof value.type === 'string') {\r\n      const name =\r\n        // `hast`\r\n        typeof value.tagName === 'string'\r\n          ? value.tagName\r\n          : // `xast`\r\n            typeof value.name === 'string'\r\n            ? value.name\r\n            : undefined\r\n\r\n      Object.defineProperty(visit, 'name', {\r\n        value:\r\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\r\n      })\r\n    }\r\n\r\n    return visit\r\n\r\n    function visit() {\r\n      /** @type {Readonly<ActionTuple>} */\r\n      let result = empty\r\n      /** @type {Readonly<ActionTuple>} */\r\n      let subresult\r\n      /** @type {number} */\r\n      let offset\r\n      /** @type {Array<UnistParent>} */\r\n      let grandparents\r\n\r\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\r\n        // @ts-expect-error: `visitor` is now a visitor.\r\n        result = toResult(visitor(node, parents))\r\n\r\n        if (result[0] === EXIT) {\r\n          return result\r\n        }\r\n      }\r\n\r\n      if ('children' in node && node.children) {\r\n        const nodeAsParent = /** @type {UnistParent} */ (node)\r\n\r\n        if (nodeAsParent.children && result[0] !== SKIP) {\r\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\r\n          grandparents = parents.concat(nodeAsParent)\r\n\r\n          while (offset > -1 && offset < nodeAsParent.children.length) {\r\n            const child = nodeAsParent.children[offset]\r\n\r\n            subresult = factory(child, offset, grandparents)()\r\n\r\n            if (subresult[0] === EXIT) {\r\n              return subresult\r\n            }\r\n\r\n            offset =\r\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\r\n          }\r\n        }\r\n      }\r\n\r\n      return result\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Turn a return value into a clean result.\r\n *\r\n * @param {VisitorResult} value\r\n *   Valid return values from visitors.\r\n * @returns {Readonly<ActionTuple>}\r\n *   Clean result.\r\n */\r\nfunction toResult(value) {\r\n  if (Array.isArray(value)) {\r\n    return value\r\n  }\r\n\r\n  if (typeof value === 'number') {\r\n    return [CONTINUE, value]\r\n  }\r\n\r\n  return value === null || value === undefined ? empty : [value]\r\n}\r\n", "/**\r\n * @typedef {import('unist').Node} UnistNode\r\n * @typedef {import('unist').Parent} UnistParent\r\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\r\n */\r\n\r\n/**\r\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\r\n *   Test from `unist-util-is`.\r\n *\r\n *   Note: we have remove and add `undefined`, because otherwise when generating\r\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\r\n *   which doesnâ€™t work when publishing on npm.\r\n */\r\n\r\n// To do: use types from `unist-util-visit-parents` when itâ€™s released.\r\n\r\n/**\r\n * @typedef {(\r\n *   Fn extends (value: any) => value is infer Thing\r\n *   ? Thing\r\n *   : Fallback\r\n * )} Predicate\r\n *   Get the value of a type guard `Fn`.\r\n * @template Fn\r\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\r\n * @template Fallback\r\n *   Value to yield if `Fn` is not a type guard.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Check extends null | undefined // No test.\r\n *   ? Value\r\n *   : Value extends {type: Check} // String (type) test.\r\n *   ? Value\r\n *   : Value extends Check // Partial test.\r\n *   ? Value\r\n *   : Check extends Function // Function test.\r\n *   ? Predicate<Check, Value> extends Value\r\n *     ? Predicate<Check, Value>\r\n *     : never\r\n *   : never // Some other test?\r\n * )} MatchesOne\r\n *   Check whether a node matches a primitive check in the type system.\r\n * @template Value\r\n *   Value; typically unist `Node`.\r\n * @template Check\r\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Check extends Array<any>\r\n *   ? MatchesOne<Value, Check[keyof Check]>\r\n *   : MatchesOne<Value, Check>\r\n * )} Matches\r\n *   Check whether a node matches a check in the type system.\r\n * @template Value\r\n *   Value; typically unist `Node`.\r\n * @template Check\r\n *   Value; typically `unist-util-is`-compatible test.\r\n */\r\n\r\n/**\r\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\r\n *   Number; capped reasonably.\r\n */\r\n\r\n/**\r\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\r\n *   Increment a number in the type system.\r\n * @template {Uint} [I=0]\r\n *   Index.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Node extends UnistParent\r\n *   ? Node extends {children: Array<infer Children>}\r\n *     ? Child extends Children ? Node : never\r\n *     : never\r\n *   : never\r\n * )} InternalParent\r\n *   Collect nodes that can be parents of `Child`.\r\n * @template {UnistNode} Node\r\n *   All node types in a tree.\r\n * @template {UnistNode} Child\r\n *   Node to search for.\r\n */\r\n\r\n/**\r\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\r\n *   Collect nodes in `Tree` that can be parents of `Child`.\r\n * @template {UnistNode} Tree\r\n *   All node types in a tree.\r\n * @template {UnistNode} Child\r\n *   Node to search for.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Depth extends Max\r\n *   ? never\r\n *   :\r\n *     | InternalParent<Node, Child>\r\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\r\n * )} InternalAncestor\r\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\r\n * @template {UnistNode} Node\r\n *   All node types in a tree.\r\n * @template {UnistNode} Child\r\n *   Node to search for.\r\n * @template {Uint} [Max=10]\r\n *   Max; searches up to this depth.\r\n * @template {Uint} [Depth=0]\r\n *   Current depth.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Tree extends UnistParent\r\n *     ? Depth extends Max\r\n *       ? Tree\r\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\r\n *     : Tree\r\n * )} InclusiveDescendant\r\n *   Collect all (inclusive) descendants of `Tree`.\r\n *\r\n *   > ðŸ‘‰ **Note**: for performance reasons, this seems to be the fastest way to\r\n *   > recurse without actually running into an infinite loop, which the\r\n *   > previous version did.\r\n *   >\r\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\r\n *   > passed, but it doesnâ€™t improve performance.\r\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\r\n *   > Using up to `10` doesnâ€™t hurt or help either.\r\n * @template {UnistNode} Tree\r\n *   Tree type.\r\n * @template {Uint} [Max=10]\r\n *   Max; searches up to this depth.\r\n * @template {Uint} [Depth=0]\r\n *   Current depth.\r\n */\r\n\r\n/**\r\n * @callback Visitor\r\n *   Handle a node (matching `test`, if given).\r\n *\r\n *   Visitors are free to transform `node`.\r\n *   They can also transform `parent`.\r\n *\r\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\r\n *   descendants to be walked (which is a bug).\r\n *\r\n *   When adding or removing previous siblings of `node` (or next siblings, in\r\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\r\n *   sibling to traverse after `node` is traversed.\r\n *   Adding or removing next siblings of `node` (or previous siblings, in case\r\n *   of reverse) is handled as expected without needing to return a new `Index`.\r\n *\r\n *   Removing the children property of `parent` still results in them being\r\n *   traversed.\r\n * @param {Visited} node\r\n *   Found node.\r\n * @param {Visited extends UnistNode ? number | undefined : never} index\r\n *   Index of `node` in `parent`.\r\n * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\r\n *   Parent of `node`.\r\n * @returns {VisitorResult}\r\n *   What to do next.\r\n *\r\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\r\n *   An `Action` is treated as a tuple of `[Action]`.\r\n *\r\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\r\n *   When the `Action` is `EXIT`, that action can be returned.\r\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\r\n * @template {UnistNode} [Visited=UnistNode]\r\n *   Visited node type.\r\n * @template {UnistParent} [Ancestor=UnistParent]\r\n *   Ancestor type.\r\n */\r\n\r\n/**\r\n * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\r\n *   Build a typed `Visitor` function from a node and all possible parents.\r\n *\r\n *   It will infer which values are passed as `node` and which as `parent`.\r\n * @template {UnistNode} Visited\r\n *   Node type.\r\n * @template {UnistParent} Ancestor\r\n *   Parent type.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   BuildVisitorFromMatch<\r\n *     Matches<Descendant, Check>,\r\n *     Extract<Descendant, UnistParent>\r\n *   >\r\n * )} BuildVisitorFromDescendants\r\n *   Build a typed `Visitor` function from a list of descendants and a test.\r\n *\r\n *   It will infer which values are passed as `node` and which as `parent`.\r\n * @template {UnistNode} Descendant\r\n *   Node type.\r\n * @template {Test} Check\r\n *   Test type.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   BuildVisitorFromDescendants<\r\n *     InclusiveDescendant<Tree>,\r\n *     Check\r\n *   >\r\n * )} BuildVisitor\r\n *   Build a typed `Visitor` function from a tree and a test.\r\n *\r\n *   It will infer which values are passed as `node` and which as `parent`.\r\n * @template {UnistNode} [Tree=UnistNode]\r\n *   Node type.\r\n * @template {Test} [Check=Test]\r\n *   Test type.\r\n */\r\n\r\nimport {visitParents} from 'unist-util-visit-parents'\r\n\r\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\r\n\r\n/**\r\n * Visit nodes.\r\n *\r\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\r\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\r\n *\r\n * You can choose for which nodes `visitor` is called by passing a `test`.\r\n * For complex tests, you should test yourself in `visitor`, as it will be\r\n * faster and will have improved type information.\r\n *\r\n * Walking the tree is an intensive task.\r\n * Make use of the return values of the visitor when possible.\r\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\r\n * to check if a node matches, and then perform different operations.\r\n *\r\n * You can change the tree.\r\n * See `Visitor` for more info.\r\n *\r\n * @overload\r\n * @param {Tree} tree\r\n * @param {Check} check\r\n * @param {BuildVisitor<Tree, Check>} visitor\r\n * @param {boolean | null | undefined} [reverse]\r\n * @returns {undefined}\r\n *\r\n * @overload\r\n * @param {Tree} tree\r\n * @param {BuildVisitor<Tree>} visitor\r\n * @param {boolean | null | undefined} [reverse]\r\n * @returns {undefined}\r\n *\r\n * @param {UnistNode} tree\r\n *   Tree to traverse.\r\n * @param {Visitor | Test} testOrVisitor\r\n *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\r\n * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\r\n *   Handle each node (when test is omitted, pass `reverse`).\r\n * @param {boolean | null | undefined} [maybeReverse=false]\r\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\r\n * @returns {undefined}\r\n *   Nothing.\r\n *\r\n * @template {UnistNode} Tree\r\n *   Node type.\r\n * @template {Test} Check\r\n *   `unist-util-is`-compatible test.\r\n */\r\nexport function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\r\n  /** @type {boolean | null | undefined} */\r\n  let reverse\r\n  /** @type {Test} */\r\n  let test\r\n  /** @type {Visitor} */\r\n  let visitor\r\n\r\n  if (\r\n    typeof testOrVisitor === 'function' &&\r\n    typeof visitorOrReverse !== 'function'\r\n  ) {\r\n    test = undefined\r\n    visitor = testOrVisitor\r\n    reverse = visitorOrReverse\r\n  } else {\r\n    // @ts-expect-error: assume the overload with test was given.\r\n    test = testOrVisitor\r\n    // @ts-expect-error: assume the overload with test was given.\r\n    visitor = visitorOrReverse\r\n    reverse = maybeReverse\r\n  }\r\n\r\n  visitParents(tree, test, overload, reverse)\r\n\r\n  /**\r\n   * @param {UnistNode} node\r\n   * @param {Array<UnistParent>} parents\r\n   */\r\n  function overload(node, parents) {\r\n    const parent = parents[parents.length - 1]\r\n    const index = parent ? parent.children.indexOf(node) : undefined\r\n    return visitor(node, index, parent)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('unist').Node} Node\r\n * @typedef {import('unist').Point} Point\r\n * @typedef {import('unist').Position} Position\r\n */\r\n\r\n/**\r\n * @typedef NodeLike\r\n * @property {string} type\r\n * @property {PositionLike | null | undefined} [position]\r\n *\r\n * @typedef PositionLike\r\n * @property {PointLike | null | undefined} [start]\r\n * @property {PointLike | null | undefined} [end]\r\n *\r\n * @typedef PointLike\r\n * @property {number | null | undefined} [line]\r\n * @property {number | null | undefined} [column]\r\n * @property {number | null | undefined} [offset]\r\n */\r\n\r\n/**\r\n * Get the ending point of `node`.\r\n *\r\n * @param node\r\n *   Node.\r\n * @returns\r\n *   Point.\r\n */\r\nexport const pointEnd = point('end')\r\n\r\n/**\r\n * Get the starting point of `node`.\r\n *\r\n * @param node\r\n *   Node.\r\n * @returns\r\n *   Point.\r\n */\r\nexport const pointStart = point('start')\r\n\r\n/**\r\n * Get the positional info of `node`.\r\n *\r\n * @param {'end' | 'start'} type\r\n *   Side.\r\n * @returns\r\n *   Getter.\r\n */\r\nfunction point(type) {\r\n  return point\r\n\r\n  /**\r\n   * Get the point info of `node` at a bound side.\r\n   *\r\n   * @param {Node | NodeLike | null | undefined} [node]\r\n   * @returns {Point | undefined}\r\n   */\r\n  function point(node) {\r\n    const point = (node && node.position && node.position[type]) || {}\r\n\r\n    if (\r\n      typeof point.line === 'number' &&\r\n      point.line > 0 &&\r\n      typeof point.column === 'number' &&\r\n      point.column > 0\r\n    ) {\r\n      return {\r\n        line: point.line,\r\n        column: point.column,\r\n        offset:\r\n          typeof point.offset === 'number' && point.offset > -1\r\n            ? point.offset\r\n            : undefined\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get the positional info of `node`.\r\n *\r\n * @param {Node | NodeLike | null | undefined} [node]\r\n *   Node.\r\n * @returns {Position | undefined}\r\n *   Position.\r\n */\r\nexport function position(node) {\r\n  const start = pointStart(node)\r\n  const end = pointEnd(node)\r\n\r\n  if (start && end) {\r\n    return {start, end}\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["index", "ok", "index", "is", "visit", "point"]
}
